[
  {
    "title": "Two Sum",
    "titleSlug": "two-sum",
    "status": "ac",
    "content": "<p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>\n\n<p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>\n\n<p>You can return the answer in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,11,15], target = 9\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,4], target = 6\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3], target = 6\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>Only one valid answer exists.</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow-up:&nbsp;</strong>Can you come up with an algorithm that is less than&nbsp;<code>O(n<sup>2</sup>)&nbsp;</code>time complexity?",
    "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    const hashmap = {}\n    \n    // Iterate through the numbers in the array,\n    for (let i=0; i<nums.length; i++) {\n        // Check the difference between the target numbers, and nums[i]\n        const difference = target - nums[i]\n        \n        // Since we know the difference between target and nums[i],\n        // we can check to see if we've seen it already, by checking if hashmap[difference] exists.\n        //\n        // If we have seen the difference before, we return the current index, \n        // and the index at which we saw the difference.\n        if (hashmap.hasOwnProperty(difference)) {\n            return [i, hashmap[difference]]\n        }\n        \n        // Otherwise, store the current number in the hashmap, \n        // along with its index\n        hashmap[nums[i]] = i\n    }\n};",
    "lang": "javascript"
  },
  {
    "title": "Add Two Numbers",
    "titleSlug": "add-two-numbers",
    "status": "ac",
    "content": "<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum&nbsp;as a linked list.</p>\n\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\" style=\"width: 483px; height: 342px;\" />\n<pre>\n<strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]\n<strong>Output:</strong> [7,0,8]\n<strong>Explanation:</strong> 342 + 465 = 807.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [0], l2 = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n<strong>Output:</strong> [8,9,9,9,0,0,0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>It is guaranteed that the list represents a number that does not have leading zeros.</li>\n</ul>\n",
    "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function(l1, l2) {\n    \n    let dummyNode = new ListNode(0);\n    let newHead = dummyNode;\n    let carry = 0;\n    \n    while(l1 || l2){\n        let valueList1 = l1 ? l1.val : 0;\n        let valueList2 = l2 ? l2.val : 0;\n        \n        let sum = valueList1 + valueList2 + carry;\n        \n        carry = Math.floor(sum/10);\n        \n        sum = sum % 10;\n        \n        newHead.next  = new ListNode(sum);\n        \n        l1 = l1 && l1.next;\n        l2 = l2 && l2.next;\n        \n        newHead = newHead.next;\n    }\n    \n    if(carry > 0) newHead.next = new ListNode(carry);\n    \n    return dummyNode.next;\n}",
    "lang": "javascript"
  },
  {
    "title": "Longest Substring Without Repeating Characters",
    "titleSlug": "longest-substring-without-repeating-characters",
    "status": "ac",
    "content": "<p>Given a string <code>s</code>, find the length of the <strong>longest substring</strong> without repeating characters.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcabcbb&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The answer is &quot;abc&quot;, with the length of 3.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bbbbb&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The answer is &quot;b&quot;, with the length of 1.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pwwkew&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The answer is &quot;wke&quot;, with the length of 3.\nNotice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of English letters, digits, symbols and spaces.</li>\n</ul>\n",
    "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let chars = [];\n    let left = 0;\n    let right = 0;\n    let res = 0;\n    while (right < s.length) {\n        let r = s.charAt(right);\n        let index = chars[r];\n        if(index !== null && index >= left && index < right) {\n            left = index + 1;\n        }\n        res = Math.max(res, right - left + 1);\n        chars[r] = right;\n        right++\n    }\n    return res;\n};",
    "lang": "javascript"
  },
  {
    "title": "Reverse Integer",
    "titleSlug": "reverse-integer",
    "status": "ac",
    "content": "<p>Given a signed 32-bit integer <code>x</code>, return <code>x</code><em> with its digits reversed</em>. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>, then return <code>0</code>.</p>\n\n<p><strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 123\n<strong>Output:</strong> 321\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = -123\n<strong>Output:</strong> -321\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 120\n<strong>Output:</strong> 21\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= x &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
    "code": "/**\n * @param {number} x\n * @return {number}\n */\nvar reverse = function(x) {\n      var reverseX = parseInt(x.toString().split('').reverse().join(''));\n    if (reverseX < (Math.pow(2, 31) * -1) || reverseX > Math.pow(2, 31) - 1) return 0;\n    return reverseX* Math.sign(x);\n};",
    "lang": "javascript"
  },
  {
    "title": "String to Integer (atoi)",
    "titleSlug": "string-to-integer-atoi",
    "status": "ac",
    "content": "<p>Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++&#39;s <code>atoi</code> function).</p>\n\n<p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p>\n\n<ol>\n\t<li>Read in and ignore any leading whitespace.</li>\n\t<li>Check if the next character (if not already at the end of the string) is <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code>. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.</li>\n\t<li>Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.</li>\n\t<li>Convert these digits into an integer (i.e. <code>&quot;123&quot; -&gt; 123</code>, <code>&quot;0032&quot; -&gt; 32</code>). If no digits were read, then the integer is <code>0</code>. Change the sign as necessary (from step 2).</li>\n\t<li>If the integer is out of the 32-bit signed integer range <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-2<sup>31</sup></code> should be clamped to <code>-2<sup>31</sup></code>, and integers greater than <code>2<sup>31</sup> - 1</code> should be clamped to <code>2<sup>31</sup> - 1</code>.</li>\n\t<li>Return the integer as the final result.</li>\n</ol>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>Only the space character <code>&#39; &#39;</code> is considered a whitespace character.</li>\n\t<li><strong>Do not ignore</strong> any characters other than the leading whitespace or the rest of the string after the digits.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;42&quot;\n<strong>Output:</strong> 42\n<strong>Explanation:</strong> The underlined characters are what is read in, the caret is the current reader position.\nStep 1: &quot;42&quot; (no characters read because there is no leading whitespace)\n         ^\nStep 2: &quot;42&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)\n         ^\nStep 3: &quot;<u>42</u>&quot; (&quot;42&quot; is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is 42.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;   -42&quot;\n<strong>Output:</strong> -42\n<strong>Explanation:</strong>\nStep 1: &quot;<u>   </u>-42&quot; (leading whitespace is read and ignored)\n            ^\nStep 2: &quot;   <u>-</u>42&quot; (&#39;-&#39; is read, so the result should be negative)\n             ^\nStep 3: &quot;   -<u>42</u>&quot; (&quot;42&quot; is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is -42.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;4193 with words&quot;\n<strong>Output:</strong> 4193\n<strong>Explanation:</strong>\nStep 1: &quot;4193 with words&quot; (no characters read because there is no leading whitespace)\n         ^\nStep 2: &quot;4193 with words&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)\n         ^\nStep 3: &quot;<u>4193</u> with words&quot; (&quot;4193&quot; is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is 4193.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>s</code> consists of English letters (lower-case and upper-case), digits (<code>0-9</code>), <code>&#39; &#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;.&#39;</code>.</li>\n</ul>\n",
    "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar myAtoi = function(s) {\n    let num = parseInt(s)\n\t\n    const negMax = -(2**31);\n    const posMax = -negMax - 1;\n\t\n    if (num >= posMax){\n        return posMax\n    }\n    if (num <= negMax){\n        return negMax\n    }\n    if (isNaN(num)){\n        return 0\n    }\n    return num \n};",
    "lang": "javascript"
  },
  {
    "title": "Palindrome Number",
    "titleSlug": "palindrome-number",
    "status": "ac",
    "content": "<p>Given an integer <code>x</code>, return <code>true</code> if <code>x</code> is palindrome integer.</p>\n\n<p>An integer is a <strong>palindrome</strong> when it reads the same backward as forward.</p>\n\n<ul>\n\t<li>For example, <code>121</code> is a palindrome while <code>123</code> is not.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 121\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 121 reads as 121 from left to right and from right to left.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = -121\n<strong>Output:</strong> false\n<strong>Explanation:</strong> From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 10\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Reads 01 from right to left. Therefore it is not a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= x &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without converting the integer to a string?",
    "code": "/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = function(x) {\n    let reversedX = '';\n    x = x.toString()\n    for(let i = 0; i < x.length; i++) {\n        reversedX = x[i] + reversedX\n    }\n    if (reversedX === x) {\n        return true\n    } else {\n        return false\n    }\n    \n};",
    "lang": "javascript"
  },
  {
    "title": "Longest Common Prefix",
    "titleSlug": "longest-common-prefix",
    "status": "ac",
    "content": "<p>Write a function to find the longest common prefix string amongst an array of strings.</p>\n\n<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\n<strong>Output:</strong> &quot;fl&quot;\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> There is no common prefix among the input strings.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>\n\t<li><code>strs[i]</code> consists of only lower-case English letters.</li>\n</ul>\n",
    "code": "/**\n * @param {string[]} strs\n * @return {string}\n */\nvar longestCommonPrefix = function(strs) {\n    // If the string is empty return empty string\n     if (strs.length === 0) return \"\";\n    // The prefix is the start of the word\n    let prefix = strs[0];\n    // Iterate over the array\n    for (let i = 1; i < strs.length; i++)\n        // Returns -1 or 0. 0 if the char matches the prefix\n        while (strs[i].indexOf(prefix) !== 0) {\n            // slices the prefix from the start to the char\n            prefix = prefix.substring(0, prefix.length - 1);\n            if (prefix.length === 0) return \"\";\n        }        \n    return prefix;\n};\n// Time: O(n), where n is the sum of all the characters in all strins\n// Space: O(1)",
    "lang": "javascript"
  },
  {
    "title": "3Sum",
    "titleSlug": "3sum",
    "status": "ac",
    "content": "<p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>\n\n<p>Notice that the solution set must not contain duplicate triplets.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [-1,0,1,2,-1,-4]\n<strong>Output:</strong> [[-1,-1,2],[-1,0,1]]\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = []\n<strong>Output:</strong> []\n</pre><p><strong>Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [0]\n<strong>Output:</strong> []\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 3000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar threeSum = function(nums) {\n    nums.sort((a,b) => a -b);\n    const result = {};\n    for(let i = 0; i < nums.length - 2; i++) {\n        let left = i + 1;\n        let right = nums.length - 1;\n        while(left < right) {\n            const sum = nums[i] + nums[left] + nums[right];\n            if (sum === 0) {\n                const key = nums[i].toString() + nums[left].toString()  + nums[right].toString();\n                result[key] = [ nums[i] , nums[left] , nums[right] ];\n            }\n            \n            if(sum < 0) {\n                left +=1;\n            } else {\n                right -=1;\n            }\n        }\n    }\n    \n    return Object.values(result);\n};",
    "lang": "javascript"
  },
  {
    "title": "Remove Nth Node From End of List",
    "titleSlug": "remove-nth-node-from-end-of-list",
    "status": "ac",
    "content": "<p>Given the <code>head</code> of a linked list, remove the <code>n<sup>th</sup></code> node from the end of the list and return its head.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], n = 2\n<strong>Output:</strong> [1,2,3,5]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1], n = 1\n<strong>Output:</strong> []\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,2], n = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>sz</code>.</li>\n\t<li><code>1 &lt;= sz &lt;= 30</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you do this in one pass?</p>\n",
    "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function(head, n) {\n    // move currentNode n steps into list\n    let currentNode = head;\n    \n    for ( let i = 0; i < n; i++) {\n        currentNode = currentNode.next;\n    }\n    \n    if (currentNode == null) {\n        return head.next;\n    }\n    \n    // move both pointers until currentNode reaches the end of list\n    let nodeBeforeRemoved = head;\n    \n    while(currentNode.next !== null) {\n        currentNode = currentNode.next;\n        nodeBeforeRemoved = nodeBeforeRemoved.next;\n    }\n    \n    nodeBeforeRemoved.next = nodeBeforeRemoved.next.next;\n    \n    return head;\n    // Time = O(n)\n    // Space = O(n)\n    \n//     let length = 0;\n//     let currentNode = head;\n    \n//     // find length of list\n//     while(currentNode !== null) {\n//         currentNode = currentNode.next;\n//         length++;\n//     }\n    \n//     if (length == n) {\n//         return head.next;\n//     }\n    \n//     // find the node to remove\n//     let nodeIndex = length - n \n//     let nodeBeforeRemovedIndex = nodeIndex - 1;\n//     currentNode = head;\n//     for(let i = 0; i < nodeBeforeRemovedIndex; i++) {\n//         currentNode = currentNode.next;\n//     }\n//     currentNode.next = currentNode.next.next;\n    \n//     return head;\n    \n//     // Time = O(n)\n//     // Space = O(1)\n    \n    \n};",
    "lang": "javascript"
  },
  {
    "title": "Valid Parentheses",
    "titleSlug": "valid-parentheses",
    "status": "ac",
    "content": "<p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>\n\n<p>An input string is valid if:</p>\n\n<ol>\n\t<li>Open brackets must be closed by the same type of brackets.</li>\n\t<li>Open brackets must be closed in the correct order.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()[]{}&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(]&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code>.</li>\n</ul>\n",
    "code": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    let hash = {\"(\":\")\", \"{\":\"}\", \"[\":\"]\"};\n    let stack = [];\n    for (let i = 0; i < s.length; i++) {\n        if(hash[s[i]]) {\n            stack.push(s[i])\n        } else {\n            if (stack.length == 0) {\n                return false;\n            }\n            let open = stack.pop();\n            if (hash[open] != s[i]) {\n                return false;\n            }\n        }\n    }\n    return stack.length === 0;\n};",
    "lang": "javascript"
  },
  {
    "title": "Merge Two Sorted Lists",
    "titleSlug": "merge-two-sorted-lists",
    "status": "ac",
    "content": "<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p>\n\n<p>Merge the two lists in a one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>\n\n<p>Return <em>the head of the merged linked list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\" style=\"width: 662px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> list1 = [1,2,4], list2 = [1,3,4]\n<strong>Output:</strong> [1,1,2,3,4,4]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [], list2 = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [], list2 = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n",
    "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\nvar mergeTwoLists = function(list1, list2) {\n    let outputList = new ListNode();\n    let selectedNode = outputList;\n    let tempNode;\n    while (true) {\n        if (list1 && list2 && list1.val <= list2.val || list1 && list2 == undefined) {\n            selectedNode.next = list1;\n            list1 = list1.next;\n        } else if (list1 && list2 || list2 && list1 == undefined) {\n            selectedNode.next = list2;\n            list2 = list2.next;\n        } else {\n            break;\n        }\n        selectedNode = selectedNode.next;\n    }\n    return outputList.next;\n};",
    "lang": "javascript"
  },
  {
    "title": "Generate Parentheses",
    "titleSlug": "generate-parentheses",
    "status": "ac",
    "content": "<p>Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 3\n<strong>Output:</strong> [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 1\n<strong>Output:</strong> [\"()\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
    "code": "/**\n * @param {number} n\n * @return {string[]}\n */\nvar generateParenthesis = function(n) {\n    const output = [];\n    const dfs = (str, open, close) => {\n    // Close parentheses can not be more than open parentheses at any \n    // given time to stay valid.\n    if (open > close) {\n      return;\n    }\n    // Base case. We now have n pairs of parentheses\n    if (open === 0 && close === 0) {\n      output.push(str);\n      return;\n    }\n    // Insert open parenthsis and search for the next valid insertion.\n    if (open > 0) {\n      dfs(`${str}(`, open - 1, close);\n    }\n    // Insert close parenthsis and search for the next valid insertion.\n    if (close > 0) {\n      dfs(`${str})`, open, close - 1);\n    }\n  };\n  dfs('', n, n);\n  return output;\n};",
    "lang": "javascript"
  },
  {
    "title": "Merge k Sorted Lists",
    "titleSlug": "merge-k-sorted-lists",
    "status": "ac",
    "content": "<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p>\n\n<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = [[1,4,5],[1,3,4],[2,6]]\n<strong>Output:</strong> [1,1,2,3,4,4,5,6]\n<strong>Explanation:</strong> The linked-lists are:\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\nmerging them into one sorted list:\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = [[]]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>k == lists.length</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= lists[i][j] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li>\n\t<li>The sum of <code>lists[i].length</code> will not exceed <code>10<sup>4</sup></code>.</li>\n</ul>\n",
    "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function(lists) {\n  var res = [];\n  var tmp = null;\n  for (var i = 0; i < lists.length; i++) {\n    tmp = lists[i];\n    while (tmp !== null) {\n      res.push(tmp);\n      tmp = tmp.next;\n    }\n  }\n  res.sort((a, b) => (a.val - b.val));\n  for (var j = 0; j < res.length; j++) {\n    res[j].next = res[j + 1] || null;\n  }\n  return res[0] || null;\n};",
    "lang": "javascript"
  },
  {
    "title": "Remove Element",
    "titleSlug": "remove-element",
    "status": "ac",
    "content": "<p>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a>. The relative order of the elements may be changed.</p>\n\n<p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code> should hold the final result. It does not matter what you leave beyond the first <code>k</code> elements.</p>\n\n<p>Return <code>k</code><em> after placing the final result in the first </em><code>k</code><em> slots of </em><code>nums</code>.</p>\n\n<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a></strong> with O(1) extra memory.</p>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The judge will test your solution with the following code:</p>\n\n<pre>\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i &lt; actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</pre>\n\n<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,2,3], val = 3\n<strong>Output:</strong> 2, nums = [2,2,_,_]\n<strong>Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,2,2,3,0,4,2], val = 2\n<strong>Output:</strong> 5, nums = [0,1,4,0,3,_,_,_]\n<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 50</code></li>\n\t<li><code>0 &lt;= val &lt;= 100</code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function(nums, val) {\n    let j = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== val) {\n            nums[j] = nums[i];\n\t    j++;\n        }\n    }\n    return j;\n\n};",
    "lang": "javascript"
  },
  {
    "title": "Next Permutation",
    "titleSlug": "next-permutation",
    "status": "ac",
    "content": "<p>A <strong>permutation</strong> of an array of integers is an arrangement of its members into a sequence or linear order.</p>\n\n<ul>\n\t<li>For example, for <code>arr = [1,2,3]</code>, the following are considered permutations of <code>arr</code>: <code>[1,2,3]</code>, <code>[1,3,2]</code>, <code>[3,1,2]</code>, <code>[2,3,1]</code>.</li>\n</ul>\n\n<p>The <strong>next permutation</strong> of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the <strong>next permutation</strong> of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).</p>\n\n<ul>\n\t<li>For example, the next permutation of <code>arr = [1,2,3]</code> is <code>[1,3,2]</code>.</li>\n\t<li>Similarly, the next permutation of <code>arr = [2,3,1]</code> is <code>[3,1,2]</code>.</li>\n\t<li>While the next permutation of <code>arr = [3,2,1]</code> is <code>[1,2,3]</code> because <code>[3,2,1]</code> does not have a lexicographical larger rearrangement.</li>\n</ul>\n\n<p>Given an array of integers <code>nums</code>, <em>find the next permutation of</em> <code>nums</code>.</p>\n\n<p>The replacement must be <strong><a href=\"http://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in place</a></strong> and use only constant extra memory.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [1,3,2]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1]\n<strong>Output:</strong> [1,2,3]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,5]\n<strong>Output:</strong> [1,5,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar nextPermutation = function(nums) {\n  var len = nums.length;\n  var i = len - 2;\n  var j = len - 1;\n  \n  while (i >= 0 && nums[i] >= nums[i + 1]) i--;\n  \n  if (i >= 0) {\n    while (j > i && nums[j] <= nums[i]) j--;\n    swap(nums, i, j);\n    reverse(nums, i + 1, len - 1);\n  } else {\n    reverse(nums, 0, len - 1);\n  }\n};\n\nvar swap = function (arr, from, to) {\n  var tmp = arr[from];\n  arr[from] = arr[to];\n  arr[to] = tmp;\n};\n\nvar reverse = function (arr, start, end) {\n  while (start < end) {\n    swap(arr, start, end);\n    start++;\n    end--;\n  }\n};",
    "lang": "javascript"
  },
  {
    "title": "Search in Rotated Sorted Array",
    "titleSlug": "search-in-rotated-sorted-array",
    "status": "ac",
    "content": "<p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p>\n\n<p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p>\n\n<p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of </em><code>target</code><em> if it is in </em><code>nums</code><em>, or </em><code>-1</code><em> if it is not in </em><code>nums</code>.</p>\n\n<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0\n<strong>Output:</strong> 4\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3\n<strong>Output:</strong> -1\n</pre><p><strong>Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1], target = 0\n<strong>Output:</strong> -1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>All values of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is an ascending array that is possibly rotated.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    for(let i = 0; i < nums.length; i++) {\n        if(nums[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n};",
    "lang": "javascript"
  },
  {
    "title": "Valid Sudoku",
    "titleSlug": "valid-sudoku",
    "status": "ac",
    "content": "<p>Determine if a&nbsp;<code>9 x 9</code> Sudoku board&nbsp;is valid.&nbsp;Only the filled cells need to be validated&nbsp;<strong>according to the following rules</strong>:</p>\n\n<ol>\n\t<li>Each row&nbsp;must contain the&nbsp;digits&nbsp;<code>1-9</code> without repetition.</li>\n\t<li>Each column must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>\n\t<li>Each of the nine&nbsp;<code>3 x 3</code> sub-boxes of the grid must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>\n</ol>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>\n\t<li>Only the filled cells need to be validated according to the mentioned&nbsp;rules.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" style=\"height:250px; width:250px\" />\n<pre>\n<strong>Input:</strong> board = \n[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]\n,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]\n,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]\n,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]\n,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> board = \n[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]\n,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]\n,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]\n,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]\n,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Same as Example 1, except with the <strong>5</strong> in the top left corner being modified to <strong>8</strong>. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>board.length == 9</code></li>\n\t<li><code>board[i].length == 9</code></li>\n\t<li><code>board[i][j]</code> is a digit <code>1-9</code> or <code>&#39;.&#39;</code>.</li>\n</ul>\n",
    "code": "/**\n * @param {character[][]} board\n * @return {boolean}\n */\nvar isValidSudoku = function(board) {\n    for (let i = 0; i < 9; i++) {\n        let row = new Set(), col = new Set(), box = new Set();\n        for (let j = 0; j < 9; j++) {\n            let _row = board[i][j];\n            let _col = board[j][i];\n            let _box = board[Math.floor(i/3) * 3+ Math.floor(j / 3)][(i % 3) * 3 + (j % 3)]\n            if (row.has(_row) || col.has(_col) || box.has(_box)) return false;\n            if (_row !== \".\") row.add(_row);\n            if (_col !== \".\") col.add(_col);\n            if (_box !== \".\") box.add(_box);\n        }\n    }\n    return true\n};",
    "lang": "javascript"
  },
  {
    "title": "Group Anagrams",
    "titleSlug": "group-anagrams",
    "status": "ac",
    "content": "<p>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>\n\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n<strong>Output:</strong> [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> strs = [\"\"]\n<strong>Output:</strong> [[\"\"]]\n</pre><p><strong>Example 3:</strong></p>\n<pre><strong>Input:</strong> strs = [\"a\"]\n<strong>Output:</strong> [[\"a\"]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code> consists of lowercase English letters.</li>\n</ul>\n",
    "code": "/**\n * @param {string[]} strs\n * @return {string[][]}\n */\nvar groupAnagrams = function(strs) {\n    // does not work on all cases\n    // let anagrams = {};\n    // for (let i = 0; i < strs.length; i++){\n    //     let sorted = strs[i].split(\"\").sort().join(\"\");\n    //     if(anagrams[sorted]) {\n    //         anagrams[sorted] += \",\" + [strs[i]] \n    //     } else {\n    //         anagrams[sorted] = strs[i]\n    //     }\n    // }\n    // let res = [];\n    // for (key in anagrams) {\n    //     let value = anagrams[key].split(\",\")\n    //     res.push(value)\n    // }\n    // return res;\n    let obj = {};\n    for (let str of strs) {\n        let letters = str.split(\"\").sort().join(\"\");\n        obj[letters] ? obj[letters].push(str) : obj[letters] = [str];\n    }\n    return Object.values(obj);\n};",
    "lang": "javascript"
  },
  {
    "title": "Maximum Subarray",
    "titleSlug": "maximum-subarray",
    "status": "ac",
    "content": "<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return <em>its sum</em>.</p>\n\n<p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> [4,-1,2,1] has the largest sum = 6.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,4,-1,7,8]\n<strong>Output:</strong> 23\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <strong>divide and conquer</strong> approach, which is more subtle.</p>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function(nums) {\n    \n    let maxValue = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i], nums[i] + nums[i-1])\n        maxValue = Math.max(maxValue, nums[i])\n    }\n    return maxValue;\n    \n};",
    "lang": "javascript"
  },
  {
    "title": "Search a 2D Matrix",
    "titleSlug": "search-a-2d-matrix",
    "status": "ac",
    "content": "<p>Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p>\n\n<ul>\n\t<li>Integers in each row are sorted from left to right.</li>\n\t<li>The first integer of each row is greater than the last integer of the previous row.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n<strong>Output:</strong> true\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= matrix[i][j], target &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
    "code": "/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nvar searchMatrix = function(matrix, target) {\n    // for(let i = 0; i < matrix.length; i++){\n    //     for(let j = 0; j < matrix[i].length; j++){\n    //         if(matrix[i][j] == target) {\n    //             return true;\n    //         }\n    //     }\n    // }\n    // return false;\n    const n = matrix.length;\n\n\tfor (let i = 0; i < n; i++) {\n\t\tif (matrix[i].indexOf(target) !== -1) return true;\n\t}\n\n\treturn false;\n};",
    "lang": "javascript"
  },
  {
    "title": "Binary Tree Level Order Traversal",
    "titleSlug": "binary-tree-level-order-traversal",
    "status": "ac",
    "content": "<p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level).</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[3],[9,20],[15,7]]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
    "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function(root) {\n      let result = [];\n      let queue = [root];\n      while (queue[0]) {\n        let queueLength = queue.length\n        let level = [];\n            for (let i = 0; i < queueLength; i++) {\n            let current = queue.shift();\n            level.push(current.val);\n            if (current.left ) queue.push(current.left);\n            if (current.right) queue.push(current.right);\n      }\n      result.push(level);\n    }\n    return result;\n};",
    "lang": "javascript"
  },
  {
    "title": "Maximum Depth of Binary Tree",
    "titleSlug": "maximum-depth-of-binary-tree",
    "status": "ac",
    "content": "<p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>\n\n<p>A binary tree&#39;s <strong>maximum depth</strong>&nbsp;is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg\" style=\"width: 400px; height: 277px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
    "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if(root === undefined || root===null){\n        return 0;\n    }\n    return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;\n};",
    "lang": "javascript"
  },
  {
    "title": "Balanced Binary Tree",
    "titleSlug": "balanced-binary-tree",
    "status": "ac",
    "content": "<p>Given a binary tree, determine if it is height-balanced.</p>\n\n<p>For this problem, a height-balanced binary tree is defined as:</p>\n\n<blockquote>\n<p>a binary tree in which the left and right subtrees of <em>every</em> node differ in height by no more than 1.</p>\n</blockquote>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg\" style=\"width: 342px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\" style=\"width: 452px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,2,3,3,null,null,4,4]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
    "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isBalanced = function(root) {\n    let dfs = function(node) {\n        if (!node) return 0;\n        let left = 1 + dfs(node.left);\n        let right = 1 + dfs(node.right);\n        if (Math.abs(left - right) > 1) return Infinity;\n        return Math.max(left, right);\n    }\n    \n    return dfs(root) == Infinity ? false : true;\n};",
    "lang": "javascript"
  },
  {
    "title": "Best Time to Buy and Sell Stock",
    "titleSlug": "best-time-to-buy-and-sell-stock",
    "status": "ac",
    "content": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>\n\n<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,1,5,3,6,4]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> In this case, no transactions are done and the max profit = 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    let buy;\n    let profit = 0;\n    \n    for(let i = 0; i < prices.length; i++) {\n        if (i == 0 || prices[i] < buy) {\n            buy = prices[i];\n        } else if (prices[i] > buy && profit < prices[i] - buy) {\n            profit = prices[i] - buy\n        }\n    }\n    return profit;\n};",
    "lang": "javascript"
  },
  {
    "title": "Binary Tree Maximum Path Sum",
    "titleSlug": "binary-tree-maximum-path-sum",
    "status": "ac",
    "content": "<p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>\n\n<p>The <strong>path sum</strong> of a path is the sum of the node&#39;s values in the path.</p>\n\n<p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 = 6.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [-10,9,20,null,null,15,7]\n<strong>Output:</strong> 42\n<strong>Explanation:</strong> The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 3 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
    "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxPathSum = function(root) {\n    let maxsum=-Infinity;\n    \n    function findmaxsum(node){\n        if(node === null) return 0;\n        const leftsum=findmaxsum(node.left);\n        const rightsum=findmaxsum(node.right);\n        \n        maxsum=Math.max(maxsum, (node.val + leftsum + rightsum), node.val, node.val + Math.max(leftsum, rightsum));\n        \n        return Math.max(node.val, node.val+ Math.max(leftsum, rightsum));\n    }\n    \n    findmaxsum(root)\n    return maxsum;\n   \n};",
    "lang": "javascript"
  },
  {
    "title": "Valid Palindrome",
    "titleSlug": "valid-palindrome",
    "status": "ac",
    "content": "<p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>\n\n<p>Given a string <code>s</code>, return <code>true</code><em> if it is a <strong>palindrome</strong>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;A man, a plan, a canal: Panama&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &quot;amanaplanacanalpanama&quot; is a palindrome.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;race a car&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;raceacar&quot; is not a palindrome.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot; &quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> s is an empty string &quot;&quot; after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists only of printable ASCII characters.</li>\n</ul>\n",
    "code": "/**\n * @param {string} s\n * @return {boolean}\n */\nvar isPalindrome = function(s) {\n    let str = s.replace(/[^A-Za-z0-9]/g, '').toLowerCase();\n    if (str == str.split(\"\").reverse().join(\"\")) {\n        return true;\n    } else {\n        return false;\n    }\n};",
    "lang": "javascript"
  },
  {
    "title": "Word Ladder",
    "titleSlug": "word-ladder",
    "status": "ac",
    "content": "<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or </em><code>0</code><em> if no such sequence exists.</em></p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n</ul>\n",
    "code": "/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n  var wordSet = new Set(wordList);\n  var queue = [];\n  var step = 0;\n  var word = '';\n  var len = 0;\n  var i = 0;\n\n  pushNextWord(beginWord, queue, wordSet);\n  step = 2;\n\n  while (len = queue.length) {\n    for (i = 0; i < len; i++) {\n      word = queue.shift();\n      if (word === endWord) return step;\n      pushNextWord(word, queue, wordSet);\n    }\n    step++;\n  }\n\n  return 0;\n};\n\nvar pushNextWord = function (word, queue, wordSet) {\n  var start = 'a'.charCodeAt(0);\n  var len = word.length;\n  var str = '';\n\n  wordSet.delete(word);\n\n  for (var i = 0; i < len; i++) {\n    for (var j = 0; j < 26; j++) {\n      str = word.substr(0, i) + String.fromCharCode(j + start) + word.substr(i + 1);\n\n      if (wordSet.has(str)) {\n        queue.push(str);\n        wordSet.delete(str);\n      }\n    }\n  }\n};",
    "lang": "javascript"
  },
  {
    "title": "Longest Consecutive Sequence",
    "titleSlug": "longest-consecutive-sequence",
    "status": "ac",
    "content": "<p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [100,4,200,1,3,2]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Therefore its length is 4.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,3,7,2,5,8,4,6,0,1]\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar longestConsecutive = function(nums) {\n    let set = new Set();\n    let c = 0, max = 0;\n    for (let num of nums) {\n        set.add(num);\n    }\n    for (let num of nums) {\n        if (!set.has(num-1)){\n            let temp = num;\n            while (set.has(temp++)) {\n                c++;\n                max = Math.max(max, c);\n            }\n            c = 0;\n        }\n    }\n    return max;\n};",
    "lang": "javascript"
  },
  {
    "title": "Palindrome Partitioning II",
    "titleSlug": "palindrome-partitioning-ii",
    "status": "ac",
    "content": "<p>Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a palindrome.</p>\n\n<p>Return <em>the minimum cuts needed</em> for a palindrome partitioning of <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aab&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ab&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> consists of lowercase English letters only.</li>\n</ul>\n",
    "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        length = len(s)\n        cuts = [i for i in range(length)]\n\n        for i in range(length):\n            # Odd size palindrome\n            j = 0 # one-character palindrome when j == 0\n            while i - j >= 0 and i + j < length and s[i - j] == s[i + j]:\n                prev_cuts = cuts[i - j - 1] if i - j - 1 >= 0 else -1\n                cuts[i + j] = min(cuts[i + j], prev_cuts + 1)\n                j += 1\n\n\t\t\t# Even size palindrome\n            j = 0\n            while i - j >= 0 and i + j + 1 < length and s[i - j] == s[i + j + 1]:\n                prev_cuts = cuts[i - j - 1] if i - j - 1 >= 0 else -1\n                cuts[i + j + 1] = min(cuts[i + j + 1], prev_cuts + 1)\n                j += 1\n\n        return cuts[-1]",
    "lang": "python3"
  },
  {
    "title": "Linked List Cycle",
    "titleSlug": "linked-list-cycle",
    "status": "ac",
    "content": "<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&nbsp;<code>next</code>&nbsp;pointer. Internally, <code>pos</code>&nbsp;is used to denote the index of the node that&nbsp;tail&#39;s&nbsp;<code>next</code>&nbsp;pointer is connected to.&nbsp;<strong>Note that&nbsp;<code>pos</code>&nbsp;is not passed as a parameter</strong>.</p>\n\n<p>Return&nbsp;<code>true</code><em> if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"width: 300px; height: 97px; margin-top: 8px; margin-bottom: 8px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"width: 141px; height: 74px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 0th node.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"width: 45px; height: 45px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n",
    "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\n// var hasCycle = function(head) {\n//     let visited = new Set();\n//     while (head !== null) {\n//         if (visited.has(head)) return true;\n//         visited.add(head);\n//         head = head.next;\n//     }\n//     return false;\n//     // Time O(n)\n//     // Space O(n)\n// };\n\nvar hasCycle = function(head) {\n    // Floyd's Tortoise And Hare Algorithm\n    let fast = head;\n    let slow = head;\n    while (fast !== null && fast.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (fast == slow) return true;\n    }\n    return false;\n    // Time O(n)\n    // Space O(1)\n};",
    "lang": "javascript"
  },
  {
    "title": "Find Minimum in Rotated Sorted Array",
    "titleSlug": "find-minimum-in-rotated-sorted-array",
    "status": "ac",
    "content": "<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(log n) time.</code></p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,5,1,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The original array was [1,2,3,4,5] rotated 3 times.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,5,6,7,0,1,2]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [11,13,15,17]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The original array was [11,13,15,17] and it was rotated 4 times. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMin = function(nums) {\n    // let min = nums[0];\n    // nums.sort((a,b) => a -b);\n    // if (nums[0] < min) return nums[0]\n    // return min;\n    // Binary Search\n    var left = 0,\n        right = nums.length - 1\n    \n    while (left < right){\n        var mid = Math.floor((left + right)/2)\n        //For an un-rotated sorted array, we can easily understand that there can never be a case where nums[mid] would ever be greater than nums[right]. However, this condition can happen in a rotated array if the mid pointer is residing on the left side of the rotated array. Once we know that the mid pointer is at the left side of the array, we can start to cut down our search to only the right side since we know that the minimum value can never be in the left side. Hence, we update the left pointer to be mid + 1, indicating that we are now searching the right side.\n\n\n        if (nums[mid] > nums[right]) left = mid + 1\n        // This condition will tell us that the subarray that we are currently searching is now a properly sorted array which is un-rotated. To get the minimum value of this subarray, we simply have to keep adjusting the right pointer to the left by setting the mid pointer as the right pointer, cutting down our serach to only the left half of this subarray. Eventually, we will reach the left most element of this subarray.\n\n        else right = mid\n    }\n    return nums[left]\n    //Time = O(logn)\n};",
    "lang": "javascript"
  },
  {
    "title": "Two Sum II - Input Array Is Sorted",
    "titleSlug": "two-sum-ii-input-array-is-sorted",
    "status": "ac",
    "content": "<p>Given a <strong>1-indexed</strong> array of integers <code>numbers</code> that is already <strong><em>sorted in non-decreasing order</em></strong>, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index<sub>1</sub>]</code> and <code>numbers[index<sub>2</sub>]</code> where <code>1 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt;= numbers.length</code>.</p>\n\n<p>Return<em> the indices of the two numbers, </em><code>index<sub>1</sub></code><em> and </em><code>index<sub>2</sub></code><em>, <strong>added by one</strong> as an integer array </em><code>[index<sub>1</sub>, index<sub>2</sub>]</code><em> of length 2.</em></p>\n\n<p>The tests are generated such that there is <strong>exactly one solution</strong>. You <strong>may not</strong> use the same element twice.</p>\n\n<p>Your solution must use only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,<u>7</u>,11,15], target = 9\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore, index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,3,<u>4</u>], target = 6\n<strong>Output:</strong> [1,3]\n<strong>Explanation:</strong> The sum of 2 and 4 is 6. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 3. We return [1, 3].\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>-1</u>,<u>0</u>], target = -1\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of -1 and 0 is -1. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>\n\t<li><code>numbers</code> is sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n\t<li>The tests are generated such that there is <strong>exactly one solution</strong>.</li>\n</ul>\n",
    "code": "/**\n * @param {number[]} numbers\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(numbers, target) {\n    let seen = {};\n    for (let i = 0; i < numbers.length; i++) {\n        let needed = seen[target - numbers[i]];\n        if (needed !== undefined) {\n            return [needed + 1, i + 1]\n        }\n        seen[numbers[i]] = i;\n    }\n};",
    "lang": "javascript"
  },
  {
    "title": "Number of Islands",
    "titleSlug": "number-of-islands",
    "status": "ac",
    "content": "<p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>\n\n<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]\n]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]\n]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n",
    "code": "/**\n * @param {character[][]} grid\n * @return {number}\n */\nvar numIslands = function(grid) {\n    let numIslands = 0;\n    \n    for(let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] == '1') {\n                numIslands = numIslands + 1;\n                bfs(grid, i , j);\n            }\n        }\n    }\n    return numIslands;\n};\n\nfunction bfs(grid, i, j) {\n    if(i < 0 || i >= grid.length || j < 0  || j >= grid[i].length || grid[i][j] == '0') {\n        return;\n    } else {\n        grid[i][j] = '0';\n        bfs(grid, i + 1, j);\n        bfs(grid, i - 1, j);\n        bfs(grid, i, j - 1);\n        bfs(grid, i, j + 1);\n    }\n}",
    "lang": "javascript"
  },
  {
    "title": "Reverse Linked List",
    "titleSlug": "reverse-linked-list",
    "status": "ac",
    "content": "<p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [5,4,3,2,1]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" style=\"width: 182px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2]\n<strong>Output:</strong> [2,1]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> A linked list can be reversed either iteratively or recursively. Could you implement both?</p>\n",
    "code": "/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar reverseList = function(head) {\n    let prevNode = null;\n    let currNode = head;\n    while (currNode) {\n        let nextNode = currNode.next;\n        currNode.next = prevNode;\n        prevNode = currNode;\n        currNode = nextNode;\n    }\n    return prevNode;\n    // Time = O(n)\n    // Space = O(1)\n};",
    "lang": "javascript"
  },
  {
    "title": "Course Schedule II",
    "titleSlug": "course-schedule-ii",
    "status": "ac",
    "content": "<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>\n\n<ul>\n\t<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>\n</ul>\n\n<p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n<strong>Output:</strong> [0,2,1,3]\n<strong>Explanation:</strong> There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 1, prerequisites = []\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are <strong>distinct</strong>.</li>\n</ul>\n",
    "code": "/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {number[]}\n */\nvar findOrder = function(numCourses, prerequisites) {\n    // Initialize result array\n    const result = new Array(numCourses).fill(0)\n    const inDegree = new Array(numCourses).fill(0);\n\n    for(const pre of prerequisites) {\n        inDegree[pre[0]]++\n    }\n\n    const zeroDegree = [];\n\n    for(let i = 0; i < numCourses; i++) {\n        if(inDegree[i]===0) {\n            zeroDegree.push(i);\n        }\n    }\n\n    // Topological sort not possible\n    if(zeroDegree.length === 0) return []\n\n    let i = 0\n    while(zeroDegree.length) {\n        const course = zeroDegree.pop()\n        // Add course to the result array \n        result[i++] = course\n        for(const pre of prerequisites) {\n            if(course === pre[1]) {\n                inDegree[pre[0]]--\n                if(inDegree[pre[0]]===0) {\n                    zeroDegree.push(pre[0])\n                }\n            }\n        }\n    }\n\n    // Topological sort not possible\n    for(const num of inDegree) {\n        if(num!== 0) return []\n    }\n\n    return result;\n};",
    "lang": "javascript"
  },
  {
    "title": "Kth Largest Element in an Array",
    "titleSlug": "kth-largest-element-in-an-array",
    "status": "ac",
    "content": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>largest element in the array</em>.</p>\n\n<p>Note that it is the <code>k<sup>th</sup></code> largest element in the sorted order, not the <code>k<sup>th</sup></code> distinct element.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [3,2,1,5,6,4], k = 2\n<strong>Output:</strong> 5\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [3,2,3,1,2,4,5,5,6], k = 4\n<strong>Output:</strong> 4\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findKthLargest = function(nums, k) {\n    let length = nums.length;\n    let rs = nums.sort((a, b) => a - b); // [1, 2, 3, 4, 5, 6]\n    console.log(rs); \n    return rs[length - k] // rs[6 - 2] == 5\n};",
    "lang": "javascript"
  },
  {
    "title": "Contains Duplicate",
    "titleSlug": "contains-duplicate",
    "status": "ac",
    "content": "<p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears <strong>at least twice</strong> in the array, and return <code>false</code> if every element is distinct.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> true\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> false\n</pre><p><strong>Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1,1,3,3,4,3,2,4,2]\n<strong>Output:</strong> true\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar containsDuplicate = function(nums) {\n    let seen = {};\n    for (let i = 0; i < nums.length; i++) {\n        if(seen[nums[i]]) {\n            return true;\n        } else {\n            seen[nums[i]] = 1;\n        }\n    }\n    return false;\n};",
    "lang": "javascript"
  },
  {
    "title": "Count Complete Tree Nodes",
    "titleSlug": "count-complete-tree-nodes",
    "status": "ac",
    "content": "<p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p>\n\n<p>According to <strong><a href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\" target=\"_blank\">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2<sup>h</sup></code> nodes inclusive at the last level <code>h</code>.</p>\n\n<p>Design an algorithm that runs in less than&nbsp;<code data-stringify-type=\"code\">O(n)</code>&nbsp;time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/complete.jpg\" style=\"width: 372px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6]\n<strong>Output:</strong> 6\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>The tree is guaranteed to be <strong>complete</strong>.</li>\n</ul>\n",
    "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar countNodes = function(root) {\n     return treeNodes(root);\n \n     function treeNodes(node){\n         if(!node){\n             return 0;\n         }else{\n             var leftDepth = 0;\n             var rightDepth = 0;\n             var leftChild = node.left;\n             while(leftChild){\n                 leftDepth++;\n                 leftChild = leftChild.left;\n             }\n             var rightChild = node.right;\n             while(rightChild){\n                 rightDepth++;\n                 rightChild = rightChild.right;\n             }\n             if(leftDepth === rightDepth){\n                 return Math.pow(2, leftDepth + 1) - 1;\n             }else{\n                 return treeNodes(node.left) + treeNodes(node.right) + 1;\n             }\n         }\n     }\n};",
    "lang": "javascript"
  },
  {
    "title": "Invert Binary Tree",
    "titleSlug": "invert-binary-tree",
    "status": "ac",
    "content": "<p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg\" style=\"width: 500px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3,6,9]\n<strong>Output:</strong> [4,7,2,9,6,3,1]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg\" style=\"width: 500px; height: 120px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> [2,3,1]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n",
    "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function(root) {\n    if (root == null) return root;\n    [root.left, root.right] = [invertTree(root.right), invertTree(root.left)];\n    return root;\n};",
    "lang": "javascript"
  },
  {
    "title": "Valid Anagram",
    "titleSlug": "valid-anagram",
    "status": "ac",
    "content": "<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"anagram\", t = \"nagaram\"\n<strong>Output:</strong> true\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"rat\", t = \"car\"\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if the inputs contain Unicode characters? How would you adapt your solution to such a case?</p>\n",
    "code": "/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar isAnagram = function(s, t) {\n    let isValid = false;\n    if (s.length !== t.length) isValid = false;\n    let sortedS = s.split(\"\").sort().join(\"\");\n    let sortedT = t.split(\"\").sort().join(\"\");\n    if(sortedS == sortedT) isValid = true;\n    return isValid;\n};",
    "lang": "javascript"
  },
  {
    "title": "Find the Duplicate Number",
    "titleSlug": "find-the-duplicate-number",
    "status": "ac",
    "content": "<p>Given an array of integers <code>nums</code> containing&nbsp;<code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p>\n\n<p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this&nbsp;repeated&nbsp;number</em>.</p>\n\n<p>You must solve the problem <strong>without</strong> modifying the array <code>nums</code>&nbsp;and uses only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,4,2,2]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,3,4,2]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums.length == n + 1</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= n</code></li>\n\t<li>All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b>Follow up:</b></p>\n\n<ul>\n\t<li>How can we prove that at least one duplicate number must exist in <code>nums</code>?</li>\n\t<li>Can you solve the problem in linear runtime complexity?</li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDuplicate = function(nums) {\n    //Traverse the array from start to end.\n    //For every element,take its absolute value:\n        //if the abs(array[i])th element is positive, the element has not encountered before, \n        //else if its negative meaning the element has been encountered before, print the                   absolute value of the current element.\n    //Works only when there is only one repeated number and nums containing n + 1 integers where       each integer is in the range [1, n] inclusive.\n    //Each encountered element modifies the value in the corresponding index in array and when we       reach an element that already was modified -it means that the index already appeared -          meaning the element is duplicated.\n    for (var i = 0; i < nums.length; i++) {\n        var absNum = Math.abs(nums[i]);\n        // If not seen yet\n        if (nums[absNum] >= 0) {\n            nums[absNum] *= -1;\n        } else {\n            return absNum;\n        }\n    }   \n};",
    "lang": "javascript"
  },
  {
    "title": "Count of Smaller Numbers After Self",
    "titleSlug": "count-of-smaller-numbers-after-self",
    "status": "ac",
    "content": "<p>You are given an integer array <code>nums</code> and you have to return a new <code>counts</code> array. The <code>counts</code> array has the property where <code>counts[i]</code> is the number of smaller elements to the right of <code>nums[i]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,2,6,1]\n<strong>Output:</strong> [2,1,1,0]\n<strong>Explanation:</strong>\nTo the right of 5 there are <b>2</b> smaller elements (2 and 1).\nTo the right of 2 there is only <b>1</b> smaller element (1).\nTo the right of 6 there is <b>1</b> smaller element (1).\nTo the right of 1 there is <b>0</b> smaller element.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1]\n<strong>Output:</strong> [0]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-1]\n<strong>Output:</strong> [0,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar countSmaller = function(nums) {\n    const sortedElements = [];\n    const smallerElements = [];\n    for (let i = nums.length - 1; i >= 0; i--) {\n        let position = binarySearch(nums[i], sortedElements);\n        if (sortedElements[position] >= nums[i] || sortedElements.length === 0) {\n            sortedElements.splice(position, 0, nums[i]);\n        } else {\n            position += 1;\n            sortedElements.splice(position, 0, nums[i]);\n        }\n        smallerElements.unshift(position);\n    }\n    return smallerElements;\n};\n\nconst binarySearch = (value, nums) => {\n    if (nums.length === 0) return 0;\n    let left = 0;\n    let right = nums.length - 1;\n    let mid = left + Math.floor((right - left) / 2);\n    while (left !== right) {\n        if (value > nums[mid]) {\n            // go right\n            left = Math.min(mid + 1, right);\n        } else if (value < nums[mid]) {\n            // go left\n            right = Math.max(mid - 1, left);\n        } else {\n            // sorta go left\n            right = mid;\n        }\n        mid = left + Math.floor((right - left) / 2);\n    }\n    return left;\n};",
    "lang": "javascript"
  },
  {
    "title": "Longest Increasing Path in a Matrix",
    "titleSlug": "longest-increasing-path-in-a-matrix",
    "status": "ac",
    "content": "<p>Given an <code>m x n</code> integers <code>matrix</code>, return <em>the length of the longest increasing path in </em><code>matrix</code>.</p>\n\n<p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[9,9,4],[6,6,8],[2,1,1]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest increasing path is <code>[1, 2, 6, 9]</code>.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[3,4,5],[3,2,6],[2,2,1]]\n<strong>Output:</strong> 4\n<strong>Explanation: </strong>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[1]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
    "code": "/**\n * @param {number[][]} matrix\n * @return {number}\n */\nvar longestIncreasingPath = function(matrix) {\n    let ylen = matrix.length, xlen = matrix[0].length, ans = 0,\n        memo = Array.from({length: ylen}, el => new Uint16Array(xlen))\n    const dfs = (y, x) => {\n        if (memo[y][x]) return memo[y][x]\n        let val = matrix[y][x]\n        memo[y][x] = 1 + Math.max(\n            y < ylen - 1 && matrix[y+1][x] < val ? dfs(y+1,x) : 0,\n            y > 0 && matrix[y-1][x] < val ? dfs(y-1,x) : 0,\n            x < xlen - 1 && matrix[y][x+1] < val ? dfs(y,x+1) : 0,\n            x > 0 && matrix[y][x-1] < val ? dfs(y,x-1) : 0)\n        return memo[y][x]\n    }\n    for (let i = 0; i < ylen; i++)\n        for (let j = 0; j < xlen; j++)\n            ans = Math.max(ans, dfs(i, j))\n    return ans\n};\n",
    "lang": "javascript"
  },
  {
    "title": "Top K Frequent Elements",
    "titleSlug": "top-k-frequent-elements",
    "status": "ac",
    "content": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1,1,2,2,3], k = 2\n<strong>Output:</strong> [1,2]\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li>\n\t<li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Your algorithm&#39;s time complexity must be better than <code>O(n log n)</code>, where n is the array&#39;s size.</p>\n",
    "code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar topKFrequent = function(nums, k) {\n    let frequency = {};\n    for (let i = 0; i < nums.length; i++) {\n        if (frequency[nums[i]]) {\n            frequency[nums[i]] += 1\n        } else {\n            frequency[nums[i]] = 1\n        }\n    }\n    \n    let sorted = Object.entries(frequency).sort((a,b)=> b[1] - a[1]) \n    let res = []\n    for (let i = 0; i < k; i++) {\n        res.push(sorted[i][0])\n    }\n\n    return res\n};",
    "lang": "javascript"
  },
  {
    "title": "Decode String",
    "titleSlug": "decode-string",
    "status": "ac",
    "content": "<p>Given an encoded string, return its decoded string.</p>\n\n<p>The encoding rule is: <code>k[encoded_string]</code>, where the <code>encoded_string</code> inside the square brackets is being repeated exactly <code>k</code> times. Note that <code>k</code> is guaranteed to be a positive integer.</p>\n\n<p>You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code>k</code>. For example, there will not be input like <code>3a</code> or <code>2[4]</code>.</p>\n\n<p>The test cases are generated so that the length of the output will never exceed <code>10<sup>5</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;3[a]2[bc]&quot;\n<strong>Output:</strong> &quot;aaabcbc&quot;\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;3[a2[c]]&quot;\n<strong>Output:</strong> &quot;accaccacc&quot;\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;2[abc]3[cd]ef&quot;\n<strong>Output:</strong> &quot;abcabccdcdcdef&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 30</code></li>\n\t<li><code>s</code> consists of lowercase English letters, digits, and square brackets <code>&#39;[]&#39;</code>.</li>\n\t<li><code>s</code> is guaranteed to be <strong>a valid</strong> input.</li>\n\t<li>All the integers in <code>s</code> are in the range <code>[1, 300]</code>.</li>\n</ul>\n",
    "code": "/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    if (!s) return '';\n    var count = '';\n    var string = '';\n    for (let i = 0; i < s.length; i++) {\n        // if letter, directily add to string\n        if (/[a-z]/.test(s[i])) string += s[i];\n        // if number\n        else if (/[0-9]/.test(s[i])) count += s[i];\n        // if open bracket\n        else if (s[i] === '[') {\n            i++;\n            // keep track of openings\n            var open = 1;\n            var substring = '';\n            while (i < s.length) {\n                if (s[i] === ']') {\n                    open--;\n                    if (open === 0) break;\n                }\n                else if (s[i] === '[') open++;\n                substring += s[i];\n                i++;\n            }\n            count = parseInt(count);\n            while (count > 0) {\n                string += decodeString(substring);    \n                count--;\n            }\n        }\n    }\n    return string;    \n};",
    "lang": "javascript"
  },
  {
    "title": "Longest Repeating Character Replacement",
    "titleSlug": "longest-repeating-character-replacement",
    "status": "ac",
    "content": "<p>You are given a string <code>s</code> and an integer <code>k</code>. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most <code>k</code> times.</p>\n\n<p>Return <em>the length of the longest substring containing the same letter you can get after performing the above operations</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ABAB&quot;, k = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Replace the two &#39;A&#39;s with two &#39;B&#39;s or vice versa.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;AABABBA&quot;, k = 1\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Replace the one &#39;A&#39; in the middle with &#39;B&#39; and form &quot;AABBBBA&quot;.\nThe substring &quot;BBBB&quot; has the longest repeating letters, which is 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of only uppercase English letters.</li>\n\t<li><code>0 &lt;= k &lt;= s.length</code></li>\n</ul>\n",
    "code": "/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar characterReplacement = function(s, k) {\n    // if empty string\n    if (!s || s.length === 0) return 0;\n    // Track letters\n    let map = {};\n    let max = 0;\n    let currentCountMax = 0;\n    let left = 0;\n    let currentLetter;\n    for (let i = 0; i < s.length; i++) {\n        currentLetter = s[i];\n        // Count the occurence of the current letter (in the present window)\n        // Track num of char occurances\n        map[currentLetter] ? map[currentLetter]++ : map[currentLetter] = 1;\n        // Update cur_count_max (in the present window)\n        if(map[currentLetter] > currentCountMax) currentCountMax = map[currentLetter];\n        // Sliding window: Check if the window we are checking is valid or not\n        // In case the size of window is bigger than cur_count_max plus max change(k)\n        // decrease the count of the leftmost letter and then slide left (left++)\n        if (i - left + 1 > currentCountMax + k) {\n            map[s[left]] -= 1;\n            left++\n        } else {\n            max = Math.max(max, i - left + 1)\n        }\n    }\n    return max;\n};",
    "lang": "javascript"
  },
  {
    "title": "Max Consecutive Ones",
    "titleSlug": "max-consecutive-ones",
    "status": "ac",
    "content": "<p>Given a binary array <code>nums</code>, return <em>the maximum number of consecutive </em><code>1</code><em>&#39;s in the array</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,0,1,1,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,1,1,0,1]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findMaxConsecutiveOnes = function(nums) {\n    let count = 0;\n    let sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] === 1) {\n            count++;\n        }\n        if (nums[i] === 0) {\n            count = 0;\n        }\n        if (count > sum) {\n            sum = count;\n        }\n    }\n    return sum;\n    \n};",
    "lang": "javascript"
  },
  {
    "title": "Cracking the Safe",
    "titleSlug": "cracking-the-safe",
    "status": "ac",
    "content": "<p>There is a safe protected by a password. The password is a sequence of <code>n</code> digits where each digit can be in the range <code>[0, k - 1]</code>.</p>\n\n<p>The safe has a peculiar way of checking the password. When you enter in a sequence, it checks the <strong>most recent </strong><code>n</code><strong> digits</strong> that were entered each time you type a digit.</p>\n\n<ul>\n\t<li>For example, the correct password is <code>&quot;345&quot;</code> and you enter in <code>&quot;012345&quot;</code>:\n\n\t<ul>\n\t\t<li>After typing <code>0</code>, the most recent <code>3</code> digits is <code>&quot;0&quot;</code>, which is incorrect.</li>\n\t\t<li>After typing <code>1</code>, the most recent <code>3</code> digits is <code>&quot;01&quot;</code>, which is incorrect.</li>\n\t\t<li>After typing <code>2</code>, the most recent <code>3</code> digits is <code>&quot;012&quot;</code>, which is incorrect.</li>\n\t\t<li>After typing <code>3</code>, the most recent <code>3</code> digits is <code>&quot;123&quot;</code>, which is incorrect.</li>\n\t\t<li>After typing <code>4</code>, the most recent <code>3</code> digits is <code>&quot;234&quot;</code>, which is incorrect.</li>\n\t\t<li>After typing <code>5</code>, the most recent <code>3</code> digits is <code>&quot;345&quot;</code>, which is correct and the safe unlocks.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Return <em>any string of <strong>minimum length</strong> that will unlock the safe <strong>at some point</strong> of entering it</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 2\n<strong>Output:</strong> &quot;10&quot;\n<strong>Explanation:</strong> The password is a single digit, so enter each digit. &quot;01&quot; would also unlock the safe.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2, k = 2\n<strong>Output:</strong> &quot;01100&quot;\n<strong>Explanation:</strong> For each possible password:\n- &quot;00&quot; is typed in starting from the 4<sup>th</sup> digit.\n- &quot;01&quot; is typed in starting from the 1<sup>st</sup> digit.\n- &quot;10&quot; is typed in starting from the 3<sup>rd</sup> digit.\n- &quot;11&quot; is typed in starting from the 2<sup>nd</sup> digit.\nThus &quot;01100&quot; will unlock the safe. &quot;01100&quot;, &quot;10011&quot;, and &quot;11001&quot; would also unlock the safe.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 4</code></li>\n\t<li><code>1 &lt;= k &lt;= 10</code></li>\n\t<li><code>1 &lt;= k<sup>n</sup> &lt;= 4096</code></li>\n</ul>\n",
    "code": "/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nvar crackSafe = function(n, k) {\n    let seen = new Set();\n    let ans = [];\n    \n    const dfs = (node, k) => {\n        for (let x = 0; x < k; ++x) {\n            const nei = node + x;\n            if (!seen.has(nei)) {\n                seen.add(nei);\n                dfs(nei.slice(1), k);\n                ans.push(x);\n            }\n        }\n    };\n    \n    if (n == 1 && k == 1) {\n        return \"0\";\n    }\n    \n    seen = new Set();\n    ans = [];\n\n    const sb = [];\n    for (let i = 0; i < n-1; ++i) {\n        sb.push(\"0\");\n    }\n    \n    const start = sb.join('');\n    dfs(start, k);\n    ans.push(start);\n    return ans.join('');\n};",
    "lang": "javascript"
  },
  {
    "title": "Binary Search",
    "titleSlug": "binary-search",
    "status": "ac",
    "content": "<p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p>\n\n<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 9\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> 9 exists in nums and its index is 4\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 2\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> 2 does not exist in nums so return -1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt; nums[i], target &lt; 10<sup>4</sup></code></li>\n\t<li>All the integers in <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted in ascending order.</li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    for(let i = 0; i < nums.length; i++) {\n        if (nums[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n};",
    "lang": "javascript"
  },
  {
    "title": "Design Circular Queue",
    "titleSlug": "design-circular-queue",
    "status": "ac",
    "content": "<p>Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called &quot;Ring Buffer&quot;.</p>\n\n<p>One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.</p>\n\n<p>Implementation the <code>MyCircularQueue</code> class:</p>\n\n<ul>\n\t<li><code>MyCircularQueue(k)</code> Initializes the object with the size of the queue to be <code>k</code>.</li>\n\t<li><code>int Front()</code> Gets the front item from the queue. If the queue is empty, return <code>-1</code>.</li>\n\t<li><code>int Rear()</code> Gets the last item from the queue. If the queue is empty, return <code>-1</code>.</li>\n\t<li><code>boolean enQueue(int value)</code> Inserts an element into the circular queue. Return <code>true</code> if the operation is successful.</li>\n\t<li><code>boolean deQueue()</code> Deletes an element from the circular queue. Return <code>true</code> if the operation is successful.</li>\n\t<li><code>boolean isEmpty()</code> Checks whether the circular queue is empty or not.</li>\n\t<li><code>boolean isFull()</code> Checks whether the circular queue is full or not.</li>\n</ul>\n\n<p>You must solve the problem without using the built-in queue data structure in your programming language.&nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyCircularQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;, &quot;isFull&quot;, &quot;deQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n<strong>Output</strong>\n[null, true, true, true, false, 3, true, true, true, 4]\n\n<strong>Explanation</strong>\nMyCircularQueue myCircularQueue = new MyCircularQueue(3);\nmyCircularQueue.enQueue(1); // return True\nmyCircularQueue.enQueue(2); // return True\nmyCircularQueue.enQueue(3); // return True\nmyCircularQueue.enQueue(4); // return False\nmyCircularQueue.Rear();     // return 3\nmyCircularQueue.isFull();   // return True\nmyCircularQueue.deQueue();  // return True\nmyCircularQueue.enQueue(4); // return True\nmyCircularQueue.Rear();     // return 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li><code>0 &lt;= value &lt;= 1000</code></li>\n\t<li>At most <code>3000</code> calls will be made to&nbsp;<code>enQueue</code>, <code>deQueue</code>,&nbsp;<code>Front</code>,&nbsp;<code>Rear</code>,&nbsp;<code>isEmpty</code>, and&nbsp;<code>isFull</code>.</li>\n</ul>\n",
    "code": "/**\n * @param {number} k\n */\nvar MyCircularQueue = function(k) {\n    this.que = new Array(k).fill(-1);\n    this.front = -1;\n    this.rear = -1;\n};\n\n/** \n * @param {number} value\n * @return {boolean}\n */\nMyCircularQueue.prototype.enQueue = function(value) {\n     if(this.rear == -1 && this.front == -1){\n        this.rear=0;\n        this.front=0;\n        this.que[0]=value;\n        return true;\n    }\n    else{\n        \n        if((this.rear + 1) % this.que.length == this.front)\n            return false;\n        else{\n            this.rear=(this.rear + 1) % this.que.length;\n            this.que[this.rear]=value;\n            return true;\n        }\n    }\n};\n\n/**\n * @return {boolean}\n */\nMyCircularQueue.prototype.deQueue = function() {\n    if(this.rear == -1 && this.front == -1){\n        return false;\n    }\n    else if(this.rear==this.front){\n        this.que[this.front]=-1;\n        this.front=-1;\n        this.rear=-1;\n        return true;\n    }\n    else{        \n        this.que[this.front]=-1;\n        this.front=(this.front+1)%this.que.length;\n        return true;\n    }  \n};\n\n/**\n * @return {number}\n */\nMyCircularQueue.prototype.Front = function() {\n    if(this.front != -1) return this.que[this.front];\n    return -1;\n};\n\n/**\n * @return {number}\n */\nMyCircularQueue.prototype.Rear = function() {\n    if(this.rear!=-1) return this.que[this.rear];\n    return -1;\n};\n\n/**\n * @return {boolean}\n */\nMyCircularQueue.prototype.isEmpty = function() {\n    return this.front==-1;\n\n};\n\n/**\n * @return {boolean}\n */\nMyCircularQueue.prototype.isFull = function() {\n    return this.front!=-1&&this.front==(this.rear+1)%this.que.length;\n};\n\n/** \n * Your MyCircularQueue object will be instantiated and called as such:\n * var obj = new MyCircularQueue(k)\n * var param_1 = obj.enQueue(value)\n * var param_2 = obj.deQueue()\n * var param_3 = obj.Front()\n * var param_4 = obj.Rear()\n * var param_5 = obj.isEmpty()\n * var param_6 = obj.isFull()\n */",
    "lang": "javascript"
  },
  {
    "title": "Robot Room Cleaner",
    "titleSlug": "robot-room-cleaner",
    "status": "ac",
    "content": "<p>You are controlling a robot that is located somewhere in a room. The room is modeled as an <code>m x n</code> binary grid where <code>0</code> represents a wall and <code>1</code> represents an empty slot.</p>\n\n<p>The robot starts at an unknown location in the room that is guaranteed to be empty, and you do not have access to the grid, but you can move the robot using the given API <code>Robot</code>.</p>\n\n<p>You are tasked to use the robot to clean the entire room (i.e., clean every empty cell in the room). The robot with the four given APIs can move forward, turn left, or turn right. Each turn is <code>90</code> degrees.</p>\n\n<p>When the robot tries to move into a wall cell, its bumper sensor detects the obstacle, and it stays on the current cell.</p>\n\n<p>Design an algorithm to clean the entire room using the following APIs:</p>\n\n<pre>\ninterface Robot {\n  // returns true if next cell is open and robot moves into the cell.\n  // returns false if next cell is obstacle and robot stays on the current cell.\n  boolean move();\n\n  // Robot will stay on the same cell after calling turnLeft/turnRight.\n  // Each turn will be 90 degrees.\n  void turnLeft();\n  void turnRight();\n\n  // Clean the current cell.\n  void clean();\n}\n</pre>\n\n<p><strong>Note</strong> that the initial direction of the robot will be facing up. You can assume all four edges of the grid are all surrounded by a wall.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>Custom testing:</strong></p>\n\n<p>The input is only given to initialize the room and the robot&#39;s position internally. You must solve this problem &quot;blindfolded&quot;. In other words, you must control the robot using only the four mentioned APIs without knowing the room layout and the initial robot&#39;s position.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/17/lc-grid.jpg\" style=\"width: 500px; height: 314px;\" />\n<pre>\n<strong>Input:</strong> room = [[1,1,1,1,1,0,1,1],[1,1,1,1,1,0,1,1],[1,0,1,1,1,1,1,1],[0,0,0,1,0,0,0,0],[1,1,1,1,1,1,1,1]], row = 1, col = 3\n<strong>Output:</strong> Robot cleaned all rooms.\n<strong>Explanation:</strong> All grids in the room are marked by either 0 or 1.\n0 means the cell is blocked, while 1 means the cell is accessible.\nThe robot initially starts at the position of row=1, col=3.\nFrom the top left corner, its position is one row below and three columns right.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> room = [[1]], row = 0, col = 0\n<strong>Output:</strong> Robot cleaned all rooms.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == room.length</code></li>\n\t<li><code>n == room[i].length</code></li>\n\t<li><code>1 &lt;= m &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>room[i][j]</code> is either <code>0</code> or <code>1</code>.</li>\n\t<li><code>0 &lt;= row &lt;&nbsp;m</code></li>\n\t<li><code>0 &lt;= col &lt; n</code></li>\n\t<li><code>room[row][col] == 1</code></li>\n\t<li>All the empty cells can be visited from the starting position.</li>\n</ul>\n",
    "code": "/**\n * // This is the robot's control interface.\n * // You should not implement it, or speculate about its implementation\n * function Robot() {\n *     // Returns true if the cell in front is open and robot moves into the cell.\n *     // Returns false if the cell in front is blocked and robot stays in the current cell.\n *     @return {boolean}\n *     this.move = function() {\n *         ...\n *     };\n *\n *     // Robot will stay in the same cell after calling turnLeft/turnRight.\n *     // Each turn will be 90 degrees.\n *     @return {void}\n *     this.turnLeft = function() {\n *         ...\n *     };\n * \n *     // Robot will stay in the same cell after calling turnLeft/turnRight.\n *     // Each turn will be 90 degrees.\n *     @return {void} \n *     this.turnRight = function() {\n *         ...\n *     };\n *\n *     // Clean the current cell.\n *     @return {void}\n *     this.clean = function() {\n *         ...\n *     };\n * };\n */\n\n/**\n * @param {Robot} robot\n * @return {void}\n */\nvar cleanRoom = function(robot) {\n  let dir = 0;\n\n  const cleaned = {};\n  const flipDir = d => (d + 2) % 4;\n  const turnRight = () => { robot.turnRight(); dir = (dir + 1) % 4; };\n  const setDir = (newDir) => { while (dir !== newDir) turnRight(); };\n\n  const recurse = (x, y, moveDir) => {\n    robot.clean();\n\n    if (cleaned[x + \" : \" + y] === true) return;\n    moveDir >= 0 && setDir(moveDir);\n\n    if (moveDir >= 0 && !robot.move()) {\n      return;\n    } else {\n      cleaned[x + \" : \" + y] = true;\n\n      // visit all non-clean adjacent squares\n      recurse(x, y - 1, 0);\n      recurse(x + 1, y, 1);\n      recurse(x, y + 1, 2);\n      recurse(x - 1, y, 3);\n    }\n    \n    // move back to our last square\n    moveDir >= 0 && setDir(flipDir(moveDir));\n    moveDir >= 0 && robot.move();\n  };\n\n  recurse(0, 0, -1);\n};",
    "lang": "javascript"
  },
  {
    "title": "Peak Index in a Mountain Array",
    "titleSlug": "peak-index-in-a-mountain-array",
    "status": "ac",
    "content": "<p>Let&#39;s call an array <code>arr</code> a <strong>mountain</strong>&nbsp;if the following properties hold:</p>\n\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>There exists some <code>i</code> with&nbsp;<code>0 &lt; i&nbsp;&lt; arr.length - 1</code>&nbsp;such that:\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li>\n\t\t<li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Given an integer array <code>arr</code> that is <strong>guaranteed</strong> to be&nbsp;a mountain, return any&nbsp;<code>i</code>&nbsp;such that&nbsp;<code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [0,1,0]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [0,2,1,0]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [0,10,5,2]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>arr</code> is <strong>guaranteed</strong> to be a mountain array.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Finding the <code>O(n)</code> is straightforward, could you find an <code>O(log(n))</code> solution?",
    "code": "/**\n * @param {number[]} arr\n * @return {number}\n */\nvar peakIndexInMountainArray = function(arr) {\n    let left = 0, right = arr.length - 1, mid;\n    while (left < right) {\n        mid = Math.floor(left + (right - left)/2);\n        if (arr[mid] < arr[mid + 1])\n            left = mid + 1;\n        else\n            right = mid;\n    }\n    return left;\n};",
    "lang": "javascript"
  },
  {
    "title": "Fruit Into Baskets",
    "titleSlug": "fruit-into-baskets",
    "status": "ac",
    "content": "<p>You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array <code>fruits</code> where <code>fruits[i]</code> is the <strong>type</strong> of fruit the <code>i<sup>th</sup></code> tree produces.</p>\n\n<p>You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:</p>\n\n<ul>\n\t<li>You only have <strong>two</strong> baskets, and each basket can only hold a <strong>single type</strong> of fruit. There is no limit on the amount of fruit each basket can hold.</li>\n\t<li>Starting from any tree of your choice, you must pick <strong>exactly one fruit</strong> from <strong>every</strong> tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.</li>\n\t<li>Once you reach a tree with fruit that cannot fit in your baskets, you must stop.</li>\n</ul>\n\n<p>Given the integer array <code>fruits</code>, return <em>the <strong>maximum</strong> number of fruits you can pick</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> fruits = [<u>1,2,1</u>]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can pick from all 3 trees.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> fruits = [0,<u>1,2,2</u>]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We can pick from trees [1,2,2].\nIf we had started at the first tree, we would only pick from trees [0,1].\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> fruits = [1,<u>2,3,2,2</u>]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> We can pick from trees [2,3,2,2].\nIf we had started at the first tree, we would only pick from trees [1,2].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= fruits.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} fruits\n * @return {number}\n */\nvar totalFruit = function(tree) {\n    let basket1;\n    let basket2;\n    var counts = [];\n    var max = 1;\n    if (tree.every( (val, i, arr) => val === tree[0] || val === tree[1] )) return tree.length;\n    var j;\n    for (var i = 0; i < tree.length - 1; i++) {\n        counts[i] = 1;\n        j = i;\n        basket1 = tree[j];\n        while (tree[j] == tree[j+1]) {\n            j++;\n            counts[i]++;\n        }\n        j++;\n        basket2 = tree[j];\n        while ((tree[j] == basket1 || tree[j] == basket2) && j < tree.length) {\n            j++;\n            counts[i]++;\n        }\n    }\n    for (var count of counts) {\n        if (count > max) max = count;\n    }\n    return max;\n};",
    "lang": "javascript"
  },
  {
    "title": "Sort Array By Parity II",
    "titleSlug": "sort-array-by-parity-ii",
    "status": "ac",
    "content": "<p>Given an array of integers <code>nums</code>, half of the integers in <code>nums</code> are <strong>odd</strong>, and the other half are <strong>even</strong>.</p>\n\n<p>Sort the array so that whenever <code>nums[i]</code> is odd, <code>i</code> is <strong>odd</strong>, and whenever <code>nums[i]</code> is even, <code>i</code> is <strong>even</strong>.</p>\n\n<p>Return <em>any answer array that satisfies this condition</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,2,5,7]\n<strong>Output:</strong> [4,5,2,7]\n<strong>Explanation:</strong> [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3]\n<strong>Output:</strong> [2,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>nums.length</code> is even.</li>\n\t<li>Half of the integers in <code>nums</code> are even.</li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow Up:</strong> Could you solve it in-place?</p>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortArrayByParityII = function(nums) {\n    let even = 0\n    let odd = 1\n    \n    while (even < nums.length && odd < nums.length){\n        if (nums[even] % 2 === 0) {\n            even += 2\n        } else if (nums[odd] % 2 === 1) {\n            odd += 2\n        } else {\n            let temp = nums[odd]\n            nums[odd] = nums[even]\n            nums[even] = temp\n        }\n    }\n    return nums\n};",
    "lang": "javascript"
  },
  {
    "title": "Unique Email Addresses",
    "titleSlug": "unique-email-addresses",
    "status": "ac",
    "content": "<p>Every <strong>valid email</strong> consists of a <strong>local name</strong> and a <strong>domain name</strong>, separated by the <code>&#39;@&#39;</code> sign. Besides lowercase letters, the email may contain one or more <code>&#39;.&#39;</code> or <code>&#39;+&#39;</code>.</p>\n\n<ul>\n\t<li>For example, in <code>&quot;alice@leetcode.com&quot;</code>, <code>&quot;alice&quot;</code> is the <strong>local name</strong>, and <code>&quot;leetcode.com&quot;</code> is the <strong>domain name</strong>.</li>\n</ul>\n\n<p>If you add periods <code>&#39;.&#39;</code> between some characters in the <strong>local name</strong> part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule <strong>does not apply</strong> to <strong>domain names</strong>.</p>\n\n<ul>\n\t<li>For example, <code>&quot;alice.z@leetcode.com&quot;</code> and <code>&quot;alicez@leetcode.com&quot;</code> forward to the same email address.</li>\n</ul>\n\n<p>If you add a plus <code>&#39;+&#39;</code> in the <strong>local name</strong>, everything after the first plus sign <strong>will be ignored</strong>. This allows certain emails to be filtered. Note that this rule <strong>does not apply</strong> to <strong>domain names</strong>.</p>\n\n<ul>\n\t<li>For example, <code>&quot;m.y+name@email.com&quot;</code> will be forwarded to <code>&quot;my@email.com&quot;</code>.</li>\n</ul>\n\n<p>It is possible to use both of these rules at the same time.</p>\n\n<p>Given an array of strings <code>emails</code> where we send one email to each <code>emails[i]</code>, return <em>the number of different addresses that actually receive mails</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> emails = [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> emails = [&quot;a@leetcode.com&quot;,&quot;b@leetcode.com&quot;,&quot;c@leetcode.com&quot;]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= emails.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= emails[i].length &lt;= 100</code></li>\n\t<li><code>emails[i]</code> consist of lowercase English letters, <code>&#39;+&#39;</code>, <code>&#39;.&#39;</code> and <code>&#39;@&#39;</code>.</li>\n\t<li>Each <code>emails[i]</code> contains exactly one <code>&#39;@&#39;</code> character.</li>\n\t<li>All local and domain names are non-empty.</li>\n\t<li>Local names do not start with a <code>&#39;+&#39;</code> character.</li>\n\t<li>Domain names end with the <code>&quot;.com&quot;</code> suffix.</li>\n</ul>\n",
    "code": "/**\n * @param {string[]} emails\n * @return {number}\n */\nvar numUniqueEmails = function(emails) {\n    let uniqueEmails = new Set();\n    \n    for (email of emails) {\n         let [local, domain] = email.split('@')\n        local = local.replace(/\\./g, '')\n        local = local.split('+')[0]\n        let newEmail = `${local}@${domain}`;\n        uniqueEmails.add(newEmail);\n    }\n  return uniqueEmails.size;\n};",
    "lang": "javascript"
  },
  {
    "title": "K Closest Points to Origin",
    "titleSlug": "k-closest-points-to-origin",
    "status": "ac",
    "content": "<p>Given an array of <code>points</code> where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents a point on the <strong>X-Y</strong> plane and an integer <code>k</code>, return the <code>k</code> closest points to the origin <code>(0, 0)</code>.</p>\n\n<p>The distance between two points on the <strong>X-Y</strong> plane is the Euclidean distance (i.e., <code>&radic;(x<sub>1</sub> - x<sub>2</sub>)<sup>2</sup> + (y<sub>1</sub> - y<sub>2</sub>)<sup>2</sup></code>).</p>\n\n<p>You may return the answer in <strong>any order</strong>. The answer is <strong>guaranteed</strong> to be <strong>unique</strong> (except for the order that it is in).</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\" style=\"width: 400px; height: 400px;\" />\n<pre>\n<strong>Input:</strong> points = [[1,3],[-2,2]], k = 1\n<strong>Output:</strong> [[-2,2]]\n<strong>Explanation:</strong>\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[3,3],[5,-1],[-2,4]], k = 2\n<strong>Output:</strong> [[3,3],[-2,4]]\n<strong>Explanation:</strong> The answer [[-2,4],[3,3]] would also be accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= points.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt; x<sub>i</sub>, y<sub>i</sub> &lt; 10<sup>4</sup></code></li>\n</ul>\n",
    "code": "/**\n * @param {number[][]} points\n * @param {number} k\n * @return {number[][]}\n */\nconst kClosest = (points = [], K) => {\n  const sorted = points.sort(\n    ([a, b], [c, d]) => Math.sqrt(a * a + b * b) - Math.sqrt(c * c + d * d),\n  )\n  return sorted.slice(0, K)\n}",
    "lang": "javascript"
  },
  {
    "title": "Squares of a Sorted Array",
    "titleSlug": "squares-of-a-sorted-array",
    "status": "ac",
    "content": "<p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing</strong> order, return <em>an array of <strong>the squares of each number</strong> sorted in non-decreasing order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-4,-1,0,3,10]\n<strong>Output:</strong> [0,1,9,16,100]\n<strong>Explanation:</strong> After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-7,-3,2,3,11]\n<strong>Output:</strong> [4,9,9,49,121]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code><span>1 &lt;= nums.length &lt;= </span>10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Squaring each element and sorting the new array is very trivial, could you find an <code>O(n)</code> solution using a different approach?",
    "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortedSquares = function(nums) {\n    for (let i = 0; i < nums.length; i++){\n        nums[i] = nums[i] * nums[i]\n    }\n    return nums.sort((a,b) => a - b)\n};",
    "lang": "javascript"
  },
  {
    "title": "Remove Vowels from a String",
    "titleSlug": "remove-vowels-from-a-string",
    "status": "ac",
    "content": "<p>Given a string <code>s</code>, remove the vowels <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code> from it, and return the new string.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcodeisacommunityforcoders&quot;\n<strong>Output:</strong> &quot;ltcdscmmntyfrcdrs&quot;\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aeiou&quot;\n<strong>Output:</strong> &quot;&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consists of only lowercase English letters.</li>\n</ul>\n",
    "code": "/**\n * @param {string} s\n * @return {string}\n */\nvar removeVowels = function(s) {\n    let array = s.split('');\n    for (let letter = 0; letter < array.length; letter++) {\n        if(array[letter] === \"a\") {\n           array[letter] = \"\"\n        } else if (array[letter] == 'e') {\n            array[letter] = \"\"\n        } else if (array[letter] == 'i') {\n            array[letter] = \"\"\n        } else if (array[letter] == 'i') {\n            array[letter] = \"\"\n        } else if (array[letter] == 'o') {\n            array[letter] = \"\"\n        } else if (array[letter] == 'u') {\n            array[letter] = \"\"\n        }\n    }\n    return array.join(\"\");\n};",
    "lang": "javascript"
  },
  {
    "title": "Optimize Water Distribution in a Village",
    "titleSlug": "optimize-water-distribution-in-a-village",
    "status": "ac",
    "content": "<p>There are <code>n</code> houses in a village. We want to supply water for all the houses by building wells and laying pipes.</p>\n\n<p>For each house <code>i</code>, we can either build a well inside it directly with cost <code>wells[i - 1]</code> (note the <code>-1</code> due to <strong>0-indexing</strong>), or pipe in water from another well to it. The costs to lay pipes between houses are given by the array <code>pipes</code> where each <code>pipes[j] = [house1<sub>j</sub>, house2<sub>j</sub>, cost<sub>j</sub>]</code> represents the cost to connect <code>house1<sub>j</sub></code> and <code>house2<sub>j</sub></code> together using a pipe. Connections are bidirectional, and there could be multiple valid connections between the same two houses with different costs.</p>\n\n<p>Return <em>the minimum total cost to supply water to all houses</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/22/1359_ex1.png\" style=\"width: 189px; height: 196px;\" />\n<pre>\n<strong>Input:</strong> n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The image shows the costs of connecting houses using pipes.\nThe best strategy is to build a well in the first house with cost 1 and connect the other houses to it with cost 2 so the total cost is 3.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2, wells = [1,1], pipes = [[1,2,1],[1,2,2]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can supply water with cost two using one of the three options:\nOption 1:\n  - Build a well inside house 1 with cost 1.\n  - Build a well inside house 2 with cost 1.\nThe total cost will be 2.\nOption 2:\n  - Build a well inside house 1 with cost 1.\n  - Connect house 2 with house 1 with cost 1.\nThe total cost will be 2.\nOption 3:\n  - Build a well inside house 2 with cost 1.\n  - Connect house 1 with house 2 with cost 1.\nThe total cost will be 2.\nNote that we can connect houses 1 and 2 with cost 1 or with cost 2 but we will always choose <strong>the cheapest option</strong>. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>wells.length == n</code></li>\n\t<li><code>0 &lt;= wells[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= pipes.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>pipes[j].length == 3</code></li>\n\t<li><code>1 &lt;= house1<sub>j</sub>, house2<sub>j</sub> &lt;= n</code></li>\n\t<li><code>0 &lt;= cost<sub>j</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>house1<sub>j</sub> != house2<sub>j</sub></code></li>\n</ul>\n",
    "code": "/**\n * @param {number} n\n * @param {number[]} wells\n * @param {number[][]} pipes\n * @return {number}\n */\nvar minCostToSupplyWater = function(n, wells, pipes) {\n    for(let i = 0; i < wells.length; i++) {\n        pipes.push([0, i + 1, wells[i]])\n    }\n    pipes.sort((a, b) => a[2] - b[2])\n    \n    let res = 0, p = []\n    for(let [u, v, cost] of pipes) {\n        let pu = find(u), pv = find(v)\n        if(pu !== pv) {\n            p[pu] = pv\n            res += cost\n            if(--n === 0) return res\n        }\n    }\n    \n    function find(x) {\n        if(p[x] === undefined) p[x] = x\n        while(x !== p[x]) {\n            p[x] = p[p[x]]\n            x = p[x]\n        }\n        return x\n    }\n};",
    "lang": "javascript"
  },
  {
    "title": "Duplicate Zeros",
    "titleSlug": "duplicate-zeros",
    "status": "ac",
    "content": "<p>Given a fixed-length integer array <code>arr</code>, duplicate each occurrence of zero, shifting the remaining elements to the right.</p>\n\n<p><strong>Note</strong> that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [1,0,2,3,0,4,5,0]\n<strong>Output:</strong> [1,0,0,2,3,0,0,4]\n<strong>Explanation:</strong> After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [1,2,3]\n<strong>Output:</strong> [1,2,3]\n<strong>Explanation:</strong> After calling your function, the input array is modified to: [1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 9</code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} arr\n * @return {void} Do not return anything, modify arr in-place instead.\n */\nvar duplicateZeros = function(arr) {\n    \n    for(let i = 0; i < arr.length - 1; i++){\n      if(arr[i] === 0){\n        for(let j = arr.length - 1; j > i; j--){\n        arr[j]=arr[j-1];\n         }\n         i++;\n       }\n\n    }\n};\n\n\n   ",
    "lang": "javascript"
  },
  {
    "title": "Defanging an IP Address",
    "titleSlug": "defanging-an-ip-address",
    "status": "ac",
    "content": "<p>Given a valid (IPv4) IP <code>address</code>, return a defanged version of that IP address.</p>\r\n\r\n<p>A <em>defanged&nbsp;IP address</em>&nbsp;replaces every period <code>&quot;.&quot;</code> with <code>&quot;[.]&quot;</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n<pre><strong>Input:</strong> address = \"1.1.1.1\"\r\n<strong>Output:</strong> \"1[.]1[.]1[.]1\"\r\n</pre><p><strong>Example 2:</strong></p>\r\n<pre><strong>Input:</strong> address = \"255.100.50.0\"\r\n<strong>Output:</strong> \"255[.]100[.]50[.]0\"\r\n</pre>\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li>The given <code>address</code> is a valid IPv4 address.</li>\r\n</ul>",
    "code": "/**\n * @param {string} address\n * @return {string}\n */\nvar defangIPaddr = function(address) {\n    return address.split(\".\").join(\"[.]\");\n};",
    "lang": "javascript"
  },
  {
    "title": "Find Numbers with Even Number of Digits",
    "titleSlug": "find-numbers-with-even-number-of-digits",
    "status": "ac",
    "content": "<p>Given an array <code>nums</code> of integers, return how many of them contain an <strong>even number</strong> of digits.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [12,345,2,6,7896]\n<strong>Output:</strong> 2\n<strong>Explanation: \n</strong>12 contains 2 digits (even number of digits).&nbsp;\n345 contains 3 digits (odd number of digits).&nbsp;\n2 contains 1 digit (odd number of digits).&nbsp;\n6 contains 1 digit (odd number of digits).&nbsp;\n7896 contains 4 digits (even number of digits).&nbsp;\nTherefore only 12 and 7896 contain an even number of digits.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [555,901,482,1771]\n<strong>Output:</strong> 1 \n<strong>Explanation: </strong>\nOnly 1771 contains an even number of digits.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findNumbers = function(nums) {\n    let evenNums = []\n    for (let i = 0; i < nums.length; i++){\n        nums[i] = nums[i].toString();\n        if (nums[i].length % 2 === 0) evenNums.push(nums[i])\n    }\n    return evenNums.length;\n};",
    "lang": "javascript"
  },
  {
    "title": "Shuffle the Array",
    "titleSlug": "shuffle-the-array",
    "status": "ac",
    "content": "<p>Given the array <code>nums</code> consisting of <code>2n</code> elements in the form <code>[x<sub>1</sub>,x<sub>2</sub>,...,x<sub>n</sub>,y<sub>1</sub>,y<sub>2</sub>,...,y<sub>n</sub>]</code>.</p>\r\n\r\n<p><em>Return the array in the form</em> <code>[x<sub>1</sub>,y<sub>1</sub>,x<sub>2</sub>,y<sub>2</sub>,...,x<sub>n</sub>,y<sub>n</sub>]</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [2,5,1,3,4,7], n = 3\r\n<strong>Output:</strong> [2,3,5,4,1,7] \r\n<strong>Explanation:</strong> Since x<sub>1</sub>=2, x<sub>2</sub>=5, x<sub>3</sub>=1, y<sub>1</sub>=3, y<sub>2</sub>=4, y<sub>3</sub>=7 then the answer is [2,3,5,4,1,7].\r\n</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,2,3,4,4,3,2,1], n = 4\r\n<strong>Output:</strong> [1,4,2,3,3,2,4,1]\r\n</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,1,2,2], n = 2\r\n<strong>Output:</strong> [1,2,1,2]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\r\n\t<li><code>nums.length == 2n</code></li>\r\n\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\r\n</ul>",
    "code": "/**\n * @param {number[]} nums\n * @param {number} n\n * @return {number[]}\n */\nvar shuffle = function(nums, n) {\n    \n     let arr = [];\n    for(let i = 0; i < n;i++){\n        arr.push(nums[i])\n        arr.push(nums[i+n])\n    }\n    return arr\n};",
    "lang": "javascript"
  },
  {
    "title": "Running Sum of 1d Array",
    "titleSlug": "running-sum-of-1d-array",
    "status": "ac",
    "content": "<p>Given an array <code>nums</code>. We define a running sum of an array as&nbsp;<code>runningSum[i] = sum(nums[0]&hellip;nums[i])</code>.</p>\r\n\r\n<p>Return the running sum of <code>nums</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,2,3,4]\r\n<strong>Output:</strong> [1,3,6,10]\r\n<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].</pre>\r\n\r\n<p><strong>Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,1,1,1,1]\r\n<strong>Output:</strong> [1,2,3,4,5]\r\n<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].</pre>\r\n\r\n<p><strong>Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [3,1,2,10,1]\r\n<strong>Output:</strong> [3,4,6,16,17]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\r\n\t<li><code>-10^6&nbsp;&lt;= nums[i] &lt;=&nbsp;10^6</code></li>\r\n</ul>",
    "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar runningSum = function(nums) {\n    let runningSum = 0;\n    let runningSumArray = [];\n    \n    for (let i = 0; i < nums.length; i++) {\n        runningSum += nums[i]\n        runningSumArray[i] = runningSum\n    }\n    return runningSumArray;\n    \n};",
    "lang": "javascript"
  },
  {
    "title": "Number of Good Pairs",
    "titleSlug": "number-of-good-pairs",
    "status": "ac",
    "content": "<p>Given an array of integers <code>nums</code>, return <em>the number of <strong>good pairs</strong></em>.</p>\n\n<p>A pair <code>(i, j)</code> is called <em>good</em> if <code>nums[i] == nums[j]</code> and <code>i</code> &lt; <code>j</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1,1,3]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1,1]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Each pair in the array are <em>good</em>.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar numIdenticalPairs = function(nums) {\n    let pairs = 0;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = 0; j < nums.length; j++) {\n            if (nums[i] == nums[j] && i < j) {\n                pairs++;\n            }\n        }\n\n    }\n    return pairs;\n};",
    "lang": "javascript"
  },
  {
    "title": "Richest Customer Wealth",
    "titleSlug": "richest-customer-wealth",
    "status": "ac",
    "content": "<p>You are given an <code>m x n</code> integer grid <code>accounts</code> where <code>accounts[i][j]</code> is the amount of money the <code>i<sup>th</sup></code> customer has in the <code>j<sup>th</sup></code> bank. Return<em> the <strong>wealth</strong> that the richest customer has.</em></p>\n\n<p>A customer&#39;s <strong>wealth</strong> is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum <strong>wealth</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> accounts = [[1,2,3],[3,2,1]]\n<strong>Output:</strong> 6\n<strong>Explanation</strong><strong>:</strong>\n<code>1st customer has wealth = 1 + 2 + 3 = 6\n</code><code>2nd customer has wealth = 3 + 2 + 1 = 6\n</code>Both customers are considered the richest with a wealth of 6 each, so return 6.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> accounts = [[1,5],[7,3],[3,5]]\n<strong>Output:</strong> 10\n<strong>Explanation</strong>: \n1st customer has wealth = 6\n2nd customer has wealth = 10 \n3rd customer has wealth = 8\nThe 2nd customer is the richest with a wealth of 10.</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> accounts = [[2,8,7],[7,1,3],[1,9,5]]\n<strong>Output:</strong> 17\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m ==&nbsp;accounts.length</code></li>\n\t<li><code>n ==&nbsp;accounts[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>1 &lt;= accounts[i][j] &lt;= 100</code></li>\n</ul>\n",
    "code": "/**\n * @param {number[][]} accounts\n * @return {number}\n */\nvar maximumWealth = function(accounts) {\n    let richestCust = 0;\n    \n    for (let i = 0; i < accounts.length; i++) {\n        let accountSum = 0;\n        for (let j = 0; j < accounts[i].length; j++) {\n            accountSum += accounts[i][j];\n        }\n        if (accountSum > richestCust) {\n            richestCust = accountSum;\n        }\n    }\n    return richestCust;\n};",
    "lang": "javascript"
  },
  {
    "title": "Build Array from Permutation",
    "titleSlug": "build-array-from-permutation",
    "status": "ac",
    "content": "<p>Given a <strong>zero-based permutation</strong> <code>nums</code> (<strong>0-indexed</strong>), build an array <code>ans</code> of the <strong>same length</strong> where <code>ans[i] = nums[nums[i]]</code> for each <code>0 &lt;= i &lt; nums.length</code> and return it.</p>\n\n<p>A <strong>zero-based permutation</strong> <code>nums</code> is an array of <strong>distinct</strong> integers from <code>0</code> to <code>nums.length - 1</code> (<strong>inclusive</strong>).</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,2,1,5,3,4]\n<strong>Output:</strong> [0,1,2,4,5,3]<strong>\nExplanation:</strong> The array ans is built as follows: \nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]\n    = [0,1,2,4,5,3]</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,0,1,2,3,4]\n<strong>Output:</strong> [4,5,0,1,2,3]\n<strong>Explanation:</strong> The array ans is built as follows:\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]\n    = [4,5,0,1,2,3]</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li>The elements in <code>nums</code> are <strong>distinct</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you solve it without using an extra space (i.e., <code>O(1)</code> memory)?</p>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar buildArray = function(nums) {\n    \n    let permutationArray = []\n    \n    for (let i = 0; i < nums.length; i++) {\n        permutationArray[i] = nums[nums[i]];\n    }\n    \n    return permutationArray;\n};",
    "lang": "javascript"
  },
  {
    "title": "Concatenation of Array",
    "titleSlug": "concatenation-of-array",
    "status": "ac",
    "content": "<p>Given an integer array <code>nums</code> of length <code>n</code>, you want to create an array <code>ans</code> of length <code>2n</code> where <code>ans[i] == nums[i]</code> and <code>ans[i + n] == nums[i]</code> for <code>0 &lt;= i &lt; n</code> (<strong>0-indexed</strong>).</p>\n\n<p>Specifically, <code>ans</code> is the <strong>concatenation</strong> of two <code>nums</code> arrays.</p>\n\n<p>Return <em>the array </em><code>ans</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1]\n<strong>Output:</strong> [1,2,1,1,2,1]\n<strong>Explanation:</strong> The array ans is formed as follows:\n- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]\n- ans = [1,2,1,1,2,1]</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,2,1]\n<strong>Output:</strong> [1,3,2,1,1,3,2,1]\n<strong>Explanation:</strong> The array ans is formed as follows:\n- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]\n- ans = [1,3,2,1,1,3,2,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar getConcatenation = function(nums) {\n    let concatArray = [];\n    \n    let numsLength = nums.length;\n    \n    for (let i = 0; i < numsLength; i++) {\n        concatArray[i] = nums[i]\n    }\n        \n    for (let j = 0; j < numsLength; j++) {\n        concatArray[j + numsLength] = nums[j]\n    }\n\n    \n    return concatArray;\n  \n};",
    "lang": "javascript"
  },
  {
    "title": "Final Value of Variable After Performing Operations",
    "titleSlug": "final-value-of-variable-after-performing-operations",
    "status": "ac",
    "content": "<p>There is a programming language with only <strong>four</strong> operations and <strong>one</strong> variable <code>X</code>:</p>\n\n<ul>\n\t<li><code>++X</code> and <code>X++</code> <strong>increments</strong> the value of the variable <code>X</code> by <code>1</code>.</li>\n\t<li><code>--X</code> and <code>X--</code> <strong>decrements</strong> the value of the variable <code>X</code> by <code>1</code>.</li>\n</ul>\n\n<p>Initially, the value of <code>X</code> is <code>0</code>.</p>\n\n<p>Given an array of strings <code>operations</code> containing a list of operations, return <em>the <strong>final </strong>value of </em><code>X</code> <em>after performing all the operations</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> operations = [&quot;--X&quot;,&quot;X++&quot;,&quot;X++&quot;]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>&nbsp;The operations are performed as follows:\nInitially, X = 0.\n--X: X is decremented by 1, X =  0 - 1 = -1.\nX++: X is incremented by 1, X = -1 + 1 =  0.\nX++: X is incremented by 1, X =  0 + 1 =  1.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> operations = [&quot;++X&quot;,&quot;++X&quot;,&quot;X++&quot;]\n<strong>Output:</strong> 3\n<strong>Explanation: </strong>The operations are performed as follows:\nInitially, X = 0.\n++X: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\nX++: X is incremented by 1, X = 2 + 1 = 3.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> operations = [&quot;X++&quot;,&quot;++X&quot;,&quot;--X&quot;,&quot;X--&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>&nbsp;The operations are performed as follows:\nInitially, X = 0.\nX++: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\n--X: X is decremented by 1, X = 2 - 1 = 1.\nX--: X is decremented by 1, X = 1 - 1 = 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= operations.length &lt;= 100</code></li>\n\t<li><code>operations[i]</code> will be either <code>&quot;++X&quot;</code>, <code>&quot;X++&quot;</code>, <code>&quot;--X&quot;</code>, or <code>&quot;X--&quot;</code>.</li>\n</ul>\n",
    "code": "/**\n * @param {string[]} operations\n * @return {number}\n */\nvar finalValueAfterOperations = function(operations) {\n    let count = 0;\n    \n    for (let i = 0; i < operations.length; i++) {\n        if (operations[i].slice(-2) == \"--\" || operations[i].slice(0,2) == \"--\" ) {\n            count--;\n        } else if (operations[i].slice(-2) == \"++\" || operations[i].slice(0,2) == \"++\") {\n            count++;\n        }\n    }\n    return count;\n};",
    "lang": "javascript"
  },
  {
    "title": "Maximum Number of Words Found in Sentences",
    "titleSlug": "maximum-number-of-words-found-in-sentences",
    "status": "ac",
    "content": "<p>A <strong>sentence</strong> is a list of <strong>words</strong> that are separated by a single space&nbsp;with no leading or trailing spaces.</p>\n\n<p>You are given an array of strings <code>sentences</code>, where each <code>sentences[i]</code> represents a single <strong>sentence</strong>.</p>\n\n<p>Return <em>the <strong>maximum number of words</strong> that appear in a single sentence</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentences = [&quot;alice and bob love leetcode&quot;, &quot;i think so too&quot;, <u>&quot;this is great thanks very much&quot;</u>]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> \n- The first sentence, &quot;alice and bob love leetcode&quot;, has 5 words in total.\n- The second sentence, &quot;i think so too&quot;, has 4 words in total.\n- The third sentence, &quot;this is great thanks very much&quot;, has 6 words in total.\nThus, the maximum number of words in a single sentence comes from the third sentence, which has 6 words.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentences = [&quot;please wait&quot;, <u>&quot;continue to fight&quot;</u>, <u>&quot;continue to win&quot;</u>]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> It is possible that multiple sentences contain the same number of words. \nIn this example, the second and third sentences (underlined) have the same number of words.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentences.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= sentences[i].length &lt;= 100</code></li>\n\t<li><code>sentences[i]</code> consists only of lowercase English letters and <code>&#39; &#39;</code> only.</li>\n\t<li><code>sentences[i]</code> does not have leading or trailing spaces.</li>\n\t<li>All the words in <code>sentences[i]</code> are separated by a single space.</li>\n</ul>\n",
    "code": "/**\n * @param {string[]} sentences\n * @return {number}\n */\nvar mostWordsFound = function(sentences) {\n    \n    let maxCount = 0;\n    \n    for (let i = 0; i < sentences.length; i++) {\n        let count = 0;\n        words = sentences[i]. split(\" \");\n        for (let j = 0; j < words.length; j++) {\n            count++;\n        }\n        if (count > maxCount) {\n            maxCount = count;\n        }\n    }\n    \n    return maxCount;\n};",
    "lang": "javascript"
  },
  {
    "title": "Add Two Integers",
    "titleSlug": "add-two-integers",
    "status": "ac",
    "content": "Given two integers <code>num1</code> and <code>num2</code>, return <em>the <strong>sum</strong> of the two integers</em>.\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = 12, num2 = 5\n<strong>Output:</strong> 17\n<strong>Explanation:</strong> num1 is 12, num2 is 5, and their sum is 12 + 5 = 17, so 17 is returned.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = -10, num2 = 4\n<strong>Output:</strong> -6\n<strong>Explanation:</strong> num1 + num2 = -6, so -6 is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-100 &lt;= num1, num2 &lt;= 100</code></li>\n</ul>\n",
    "code": "/**\n * @param {number} num1\n * @param {number} num2\n * @return {number}\n */\nvar sum = function(num1, num2) {\n    return num1 + num2\n};",
    "lang": "javascript"
  },
  {
    "title": "Intersection of Two Arrays",
    "titleSlug": "intersection-of-two-arrays",
    "status": "ac",
    "content": "<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]\n<strong>Output:</strong> [2]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n<strong>Output:</strong> [9,4]\n<strong>Explanation:</strong> [4,9] is also accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n",
    "code": "/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersection = function(nums1, nums2) {\n    let result = [];\n    let setNum1 = new Set(nums1);\n    let setNum2 = new Set(nums2);\n\n    let [smallSet , largeSet] = (setNum1.length < setNum2.length) ? [setNum1 , setNum2] : [setNum2 , setNum1];\n\n    smallSet.forEach( num => {\n        largeSet.has(num) && result.push(num);\n    });\n\n    return result;\n    // Time: O(n)\n    // Space: O(n)\n};",
    "lang": "javascript"
  }
]